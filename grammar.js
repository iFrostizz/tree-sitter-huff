const CODES = [
  'stop',
  'add',
  'mul',
  'sub',
  'div',
  'sdiv',
  'mod',
  'smod',
  'addmod',
  'mulmod',
  'exp',
  'signextend',
  'lt',
  'gt',
  'slt',
  'sgt',
  'eq',
  'iszero',
  'and',
  'or',
  'xor',
  'not',
  'byte',
  'sha3',
  'keccak',
  'address',
  'balance',
  'origin',
  'caller',
  'callvalue',
  'calldataload',
  'calldatasize',
  'calldatacopy',
  'codesize',
  'codecopy',
  'gasprice',
  'extcodesize',
  'extcodecopy',
  'returndatasize',
  'returndatacopy',
  'blockhash',
  'coinbase',
  'timestamp',
  'number',
  'difficulty',
  'gaslimit',
  'chainid',
  'selfbalance',
  'basefee',
  'pop',
  'mload',
  'mstore',
  'mstore8',
  'sload',
  'sstore',
  'jump',
  'jumpi',
  'getpc',
  'msize',
  'gas',
  'jumpdest',
  'push1',
  'push2',
  'push3',
  'push4',
  'push5',
  'push6',
  'push7',
  'push8',
  'push9',
  'push10',
  'push11',
  'push12',
  'push13',
  'push14',
  'push15',
  'push16',
  'push17',
  'push18',
  'push19',
  'push20',
  'push21',
  'push22',
  'push23',
  'push24',
  'push25',
  'push26',
  'push27',
  'push28',
  'push29',
  'push30',
  'push31',
  'push32',
  'dup1',
  'dup2',
  'dup3',
  'dup4',
  'dup5',
  'dup6',
  'dup7',
  'dup8',
  'dup9',
  'dup10',
  'dup11',
  'dup12',
  'dup13',
  'dup14',
  'dup15',
  'dup16',
  'swap1',
  'swap2',
  'swap3',
  'swap4',
  'swap5',
  'swap6',
  'swap7',
  'swap8',
  'swap9',
  'swap10',
  'swap11',
  'swap12',
  'swap13',
  'swap14',
  'swap15',
  'swap16',
  'shl',
  'shr',
  'sar',
  'log0',
  'log1',
  'log2',
  'log3',
  'log4',
  'create',
  'call',
  'callcode',
  'return',
  'delegatecall',
  'create2',
  'staticcall',
  'revert',
  'invalid',
  'selfdestruct',
]

module.exports = grammar({
  name: 'huff',
  
  extras: $ => [
    $.comment,
    /[\s\uFEFF\u2060\u200B\u00A0]/ 
  ],
  rules: {
    source_file: $ => repeat($.definition),
    definition: $ => choice(
      $.keyword_definition,
      $.interface_definition,
      $.constant_definition,
    ),
    _declaration: $ => seq(
      $.identifier,
      $.parameters,
    ),
    _def_params: $ => seq(
      $._declaration,
      $.visibility,
      $.val_parameters,
    ),
    _def_const: $ => seq(
      $.identifier,
      ' = ',
      $.constant,
    ),
    def_val: $ => '#define',
    keyword: $ => choice(
      'macro',
      'fn',
      'takes',
      'returns',
      'function',
      'constant',
    ),
    _def: $ => seq(
      $._declaration,
      ' = ',
      $.val_parameters,
      $.val_parameters,
      $.block
    ),
    keyword_definition: $ => seq(
      $.def_val,
      $.keyword,
      $._def
    ),
    interface_definition: $ => seq(
      $.def_val,
      $.keyword,
      $._def_params,
    ),
    constant_definition: $ => seq(
      $.def_val,
      $.keyword,
      $._def_const,
    ),
    val_parameters: $ => seq(
      $.keyword,
      $.parameters
    ),
    block: $ => seq(
      '{',
      repeat($._statement),
      '}',
    ),
    _statement: $ => choice(
      $.opcode,
      $.label,
      $.hex,
      $.const_access,
      $.macro_call,
    ),
    opcode: $ => choice(...CODES),
    label: $ => choice(
      $._label,
      $._destination,
    ),
    _label: $ => /[A-Za-z_]+/,
    _destination: $ => seq( // TODO: label and destination collision
      /[A-Za-z_]+/,
      ":",
    ),
    hex: $ => /0[xX][0-9a-fA-F]+/,
    const_access: $ => seq(
      "[",
      $.identifier,
      "]",
    ),
    macro_call: $ => seq(
      $.identifier,
      "()",
    ),
    const: $ => seq(
                  $.identifier,
                  "()",
                ),
    identifier: $ => /[A-Za-z_]+/,
    parameters: $ => seq(
      "(",
      repeat(
        seq(
          $.parameter,
          /[,]?/,
        )
      ),
      ")"
    ),
    parameter: $ => seq(
      $._single_parameter,
    ),
    _single_parameter: $ => /[A-Za-z0-9]+/,
    visibility: $ => choice(
      "view",
      "pure",
      "payable",
      "nonpayable"
    ),
    constant: $ => choice(
      $.const,
      $.hex
    ),
    comment: $ => token(
                    choice(
                            seq('//', /([^\r\n])*/),
                            seq(
                                  '/*',
                                  /[^*]*\*+([^/*][^*]*\*+)*/,
                                  '/'
                              )
                        )
              ),
            }
});
